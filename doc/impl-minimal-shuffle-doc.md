Bayer-Groth minimal shuffle:

# The algorithm reads a configuration file, called *config*, to set
  the parameters and the groups (Functions::read_config())

The function receives two arguments, *num*, a vector of type long containing
the number of ciphertexts and the structure of the matrix of the
ciphertexts and, *genq*, the generator of group? Z_q.

Specifically, given a matrix of ciphertexts N = m x n then: 

* num[0] = actual number of ciphertexts used in the shuffle protocol, e.g. 400
<--why 400?-->
* num[1] = number of rows (m), e.g. 16
* num[2] = number of columns (n), e.g. 5
* num[3] = window size of the multi-exponentiation technique by Brickels et al.; 
  default value is 7, e.g. 7
* num[4] = window size for the sliding window multi-exponentiation technique; 
  default value is 5 for q 160 bits else 6, e.g. 6
* num[5] = variant of the minimal shuffle to execute, e.g. 3,: 
** 0-no optimization
** 1-multi-exponentiation techniques
** 2-multi-exponentiation techniques and FFT to find values E_i
** 3-multi-exponentiation techniques, extra interation, and Toom-Cook 4
   to find values E_i, in this case m=16 or m=64
* num[6] = Types of groups uses. With 0 the same modular group G is used for 
  the commitments and the encryption; with 1 the commitments are calculated in G 
  subset Z_p_1 with order q and the encryption in H subset Z_p_2 with order q, 
  e.g. 0
* num[7] = window size of the multi-exponentiation technique by Lim and Lee; 
  default value is 5, e.g. 5

Then the configuration continues according to parameters of the file as follows.

* If the line read is not the zero string ("0") then:
** uses the line read to open the file (the line is the name of the file 
   consisting the description of the groups 
   used in the protocol. If only one group is used the file should consist of 
   the prime p, prime order q, a generator of G and a generator of Z_q.
   If two different groups are used the file should consist of the prime p, 
   prime order q, a generator of G, a generator of Z_q, the prime p1 and a generator of H.
   Or set parameter to 0 if you want to define groups of own choice.)
** if the same modular group G is used for the commitments and the encryption (see num[6])
   then reads the first four lines into a vector of numbers belonging to Z_q. With these
   numbers the groups G and H are set using the exact same parameter values. The parameters
   are:
*** the generator of the group (third line of the file)
*** the order of the group (second lof)
*** the value of p such that G_q is a subset of Z_p (first lof)
** else if different groups are used then reads the first six lines from the file and uses
   different parameter values to set the two groups. For the first group the values are as noted.
   For the second group the values are:
*** the generator of the group (sixth line of the file)
*** the order of the group (second lof)
*** the value of p such that G_q is a subset of Z_p (fifth lof)
* else (if no file name is provided) it calls a function that
  finds:
** prime numbers q,p such that p = 2*a*q+1 using test provided by Mau94?, 
   by passing as arguments the number of bits of q,p, and
** the generator of the group.

Again, the groups are set according to the strategy set in num[6].

Finally, the group, the order, and the generator of ElGamal are set.

# The Pedersen commitment scheme is set up.

First, the object that calculates the commitments is created given 

* the number of columns n, denoted by *num[2]*,
* and a group *G*.

The constructor generates an instance of Pedersen with group G,
which is able to commit up to n elements, that is:

* sets the group G as the group used for the commitment scheme
* sets the vector of generators, *gen*; this is the public key of the commitment.
Each value (Z_p) in gen is generated from group H and raised in the power of a randomly
generated number (seed is current time) belonging to Z_q.

Then given num[3], num[7], and num[4] the commitment's
omega is set:

* omega_expo (window size used for multi-expo) = num[3]
* omega_ll (window size used for multi-expo Lim and Lee) = num[7]
* omega_sw (window size used for sliding window) = num[4]

Finally, *gen_prec*, the vector containing the precomputated values 
of the first two generators (gen->at(0), gen->at(1)) for SW algorithm is set.

# The ciphertext vector of ElGamal encryptions is created.

A vector *c* of num[0] or N El Gamal template ciphertext objects is created.
This vector together with the vector *num*, which contains the number of
ciphertext and the structure of the matrix of ciphertexts, are input to generate
N=num[0] different ciphertexts. 
If N<n*m 1 is encrypted in the last elements.
Each El Gamal ciphertext is created using two random numbers:
* one generated by RandomBnd(n), which returns a number between 0 and n-1, and 
* another returned by the group's, H, random
generator, by calling *random_el()*. 
This returns a random element of the group without setting the seed.
Specifically, it gets a random number smaller than the order of the group by calling 
NTL's RandomBnd() and raises the generator of the group to this value.

# The ciphertext vector is permuted and reencrypted.

A matrix, *pi*, num[1]xnum[2] (mxn) is created and passed to a function
that **permutes** it. The function calculates a mxn matrix containing a permutation from N = n*m values. 
For each value in the vector it calculates the associated position in a matrix and saves this.
For example N 0 15, m=3, n = 5, if the first value in the permutation vector is 7, then the element in 
position (0,0) of the matrix would be (1,1).

Next, a matrix of random elements *R* is generated in randomEl(), which is used in the reencryption process.
The ciphertext vector *c* is reencrypted using the permutation *pi* and random elements *R*.
The reencryption process for each element (i,j) in the ciphertext matrix *c* is the following:
1. An El Gamal cipher is generated using 1 as the encryption function and random element (i,j) from R
2. The element in *c* to be reencrypted, i.e. the row and column, is decided by looking up *pi* for (i,j).
3. The element in *c* indexed by (row, column) retrieved from *pi* is multiplied with the cipher generated
   at step 1. Multiplication calls MulMod NTL library function for ZZ multiplication between the fields
   of the two El Gamal ciphertexts temp, c[row][column]. The fields are:
* ZZ u,v where u,v represent u=g^r, v = y^r m, where r is random, y is the public key and m the message
* ZZ mod, modular values of the calculations in the cyclic group

mu=4 number of rows after reduction
m_r=4 is the number of rows after reduction (num[1]/mu).
mu_h=7 (2*mu -1) is the number of extra elements in the reduction 

# Shuffle correctness process takes place. It involves 10 rounds where prover and
  verifier carry out computations interchangeably. This documentation ivolves
  the Toom-Cook optimization method coupled with interaction to reduce computation
  further.
  The optimization function receives as input:
  * the encrypted ciphertext matrix *c*,
  * the reencrypted ciphertext matrix *C*,
  * the vector of random elements *R*,
  * the permutation matrix *pi*,
  * the vector holding the number of ciphertexts and the structure of
    the matrix of ciphertexts *num*, and
  * the generator of group Z_q *genq*.

An instance of the prover for Toom-based optimization is created given
c, R, pi, num, and genq. The prover records these in private fields and
sets up numerous data structures needed in the proof process.
We will refer to those in the corresponding rounds where they play their role.
The constructor creates and sets up matrix *A* by permuting the matrix *X* regarding the
permutation *pi*. A is the matrix containing the numbers 1 to N after the permutation.

An instance of the verifier for Toom-based optimization is created given
num. It also sets up numerous data structures used in the verification
process.
     
## In Round 1 (P) picks random elements and commits to the rows of matrix A
<--round_1 calculates and returns the commitment to the row in Y-->
It calculates commitments *c_A to rows of A given:
* *A* and
* random elements to generate the commitments for A, *r_A*.
So the commitment function commit_op() picks random values and commit to matrix A.
Internally it invokes the commitment function of the Pedersen scheme (commit _opt()) 
and commits to a vector, or row of a matrix at once. It writes those to file named
"round_1 ".

## Round 2: (V) reads commitments from the file and stores them to matrix c_A. 
   It then sends challenges chal_x2, a random ZZ number, which defines the exponents 
   for permutation.

## In Round 3 (P) calculates and returns the commitment to permuted exponents 
   s_1(i)*s_2(j).

   Reads the challenge sent by (V) from file and sets *chal_x2* by calling set_x2().
   This means multiplying x2 with itself to create a matrix with x2,..., x2^N. 
   The N elements are stored in mxn matrix *chal_x2*.
   Then it permutes chal_x2 according to *pi* to create matrix *B*, the
   matrix of permuted Vandermond challenges, generated out of challenges *x2*.
   In the same function (set_B_op()) the *basis_B* vector is set.
   This matrix contains the basis_vec for multi-expo.
   <--Essentially, given the window size for multi-expo technique-->
   
   Finally, it commits to rows in B and writes the commitment to file "round 3 ".

## Round 4 (V) stores commitments of matrix B, *c_B* read from file and sends challenges
   *chal_y4* and *chal_z4* to the prover by writing them to file named "round 4 ".
   The challenges are used to verify that the same permutation is used.


If ((m_r = num[1]/mu) == 4) ? what follows ; round_x_red versions.

## Round 5 (P) a) calculates D and the commitments to the vectors chal_z, D_h
               b) 
     
round_5a calculates the commitments to the vectors *z* and *D_h* and returns them
given challenges *chal_y4* and *chal_z4* read from file.
First, in *set_D()*, it sets the D matrix by calculating y* A_ij + B_ij -z 
for each value in the first m rows in D (D is initialized with m+1 rows).
Then it sets the matrix *D_h* as the Hadamard product of the rows in D.
Sets up vector *z* by assigning to all of its values *chal_z4*.
Sets the additional raow in D to contain -1.
Calculates commitment to vector z, *c_z* and matrix D_h, *c_D_h*.

In round 5b ZZ number *R_b* is set up, which contains the negative sum of B_ij*R_ij.
Then the algorithm retrieves randomly the exponents used in Toom-cook given the order
of the encryption group H.
<--these are the omega values in the paper-->
It stores them in vector a_c and commits to them (commit_ac()).
*r_c* is the vector of random elements used to commit to a_c (the randomizer).
Vector *rho_c* contains random elements used for the reencryption.
The values of vectors a_c, r_c, and rho_c at position mu-1 are zeroed.
This is the position that corresponds to the main diagonal.
The sliding window commitments of a_c are in vector *c_a_c*.
<--a_c->at(mu-1) = to_ZZ(0);-->
Then the algorithm calculates the product of chosen (6) diagonals of the ciphertext 
matrix by dividing the matrix in 4x4 blocks and only use the four blocks that are 
on the main diagonal (calculate_Cc()).
It then calculates the modular exponent of the encryption group H generator over 
the Toom-Cook exponent modulo the group's modulo, reencrypts it 
using vactor of random elements *rho_c*,
and multiples it with the product of the diagonal to get the vector *C_c*
used to prove the correctness of the reduction.

It writes commitments c_D_h, C_c, and c_a_c to file "round_5 ".
<--In red version the following are calculated too-->
<--ZZ number a_c_bar, the sum over elements to reencrypt E_low_up,-->
<--and ZZ *r_ac_bar*, a sum over random elements.-->

## Round 6 (V) reads c_Dh, C_c, and c_a_c from file.
Fills vectors *chal_x6* and *chal_y6* of size ... by 
retrieving a random value of order equal to the order 
of the encryption group and multiplying it with itself to compute
values of the vector.
Effectively, the values of the vector are: temp, temp^2, ...
It writes the vectors to file "round_6 ".

## Round 7 (P) reads in vectors *chal_x6* and *chal_y6*.
               
Round_7a sets up *D_s* matrix (vector of rows) of size m+1, which contains the 
shifted Hadamar products in *D_h* in set_D_s() given D_h, D, and chal_x6. 
It multiplies challenges with D_h at every row at every column except the final
one: D_s(i) = chal_x6(i), or chal_x6^(i+1)*D_h(i) for i<m-1 and 
Then it multiplies chal_x6(i) with D_h(i+1)(j) to get *r_Dl_bar* and holds the 
sum of each *column* j in *ds_temp(j)*.
Vector *ds_temp* is set to be the pre-last row of D_s:
D_s(m-1) = sum(chal_x6^i+1 * D_s(i+1).
It also sets last row of D_s and first row of D to random values.

In commit_dl_op() it calculates the values Dls as 
Dl(l) = sum(D(i)*D_s->at(i)*chal_y6) for j=n+i-l and commits to the values.

It computes the bilinear map of D and D_s as the Hadamard product between each row of D_s 
and vector chal_y6, then the product of rows of D and D_s and finally the sum of
each product is stored and returned in the end.
The bilinear map for all columns of each row is summed and stored in vector *Dl*.
Consequently, Dl contains the sums of bilinear maps of rows of D and D_s.
Then *r_Dl* is set up, a vector of size 2m+1 of random elements for the commitments to D_l
(except for position m+1 where it contains 0).
Finally the commitment to values of Dl is computed and stored in vector *c_Dl*.

Then it commits to the first row of D, *c_D0*, using randomizer *r_D0*
and the mth row of D_s, *c_Dm*, using randomizer *r_Dm*.
Then in commit_d_op(), commit_Delta_op(), and commit_d_h_op() 
it computes commitments c_d, c_Delta, and c_d_h to prove that the product over the elements 
in D_h->at(m) is the desired product of n *y + x2n -z.
*d* and *Delta* are retrieved randomly. 
*Delta* has value of D at position 0 and value 0 at position n-1.
c_Delta commitment is the negative modulo of the product between Delta(i) and d(i+1).
*d_h* at position 0 has value of m-1 row of D_h at position 0.
The other positions consist of the multiplication modulo of d_h(i-1) and D_h(m-1)(i).
c_d_h commitment is the subtraction modulo between the multiplication modulo of d_h(i)
and D_h(i+1) and the subtraction modulo between Delta(i+1) and the multiplication 
modulo between D_h(m-1)(i+1) and Delta(i).

In round_7b ZZ *a_c_bar*, the sum over elements to reencrypt E_low_up,
and ZZ *r_ac_bar*, a sum over random elements, are calculated.
a_c_bar is the sum of the multiplicative modulo between Toom-Cook exponents 
a_c(i) and chal_x6(i-1).
Similarly, r_ac_bar is the sum of the multiplicative modulo between 
r_c(i) and chal_x6(i-1).

In round 7c the algorithm reduces C (reduce_C()) given C, B, chal_x6, and m_r
to a smaller matrix of ciphertexts used for interaction.
Each row C_small(i) is a vector of ciphertexts of size n (the original matrix's columns), 
where each ciphertext is computed upon a column and is the multi-exponentiation result 
of ciphertexts in four (m_r=4) rows, e.g. 
C_small(0,0)=multi_expo(C[0][0],C[1][0],C[2][0],C[3][0]).
Each row B_small(i) is the sum modulo of multiplication modulos between matrix *B* 
and vector similar to *chal_x6*, that is for each column in a row we have:
B(4i,j)*x_temp(3) + B(4i+1)*x_temp(2) + B(4i+2)*x_temp(1) + B(41+3,j)*x_temp(0).
Multiplications and additions are the modulo ones.
*r_b_small* is computed in the same fashion as B_small.
Then R_b is re-setup as the sum modulo of the multiplication modulo between
rho_c(i) and chal_x6(i-1) over 6 (<mu_h=7) iterations.
Then the vector *a* containing exponents for reencryption is retrieved randomly (m=a.length()/2)
in commit_a_op() together with random values *r_a* used for its commitment
*c_a*. mth exponent and random values are set to 0.
Then another identical loop sets and commits the other m half of the exponent values.
B0 vector of size n is randomly set at commit_B0_op() along with *r_B0* value used for
its commitment *c_B0*.
In this function *basis_B0* is also computed as multi_expo:to_basis(B0(i), NumBits(ord)).
To calculate the di values:
Toom-Cook multiplication happens between C_small and B_small and produces a vector
of ciphertexts *dt*.
Ciphertext e(0) is the result of exponential multiplication between C_small(mu-1) and
basis_B0.
Ciphertexts e(k<mu) are the result of exponential multiplication between C_small(mu-k-1)
and basis_B0 multiplied by dt(2mu-k-1).
Finally, ciphertexts e(mu=k<2mu) are assigned from dt[2mu-k-1].
Ciphertext e stores the di values (?).
Vector *rho_a* is set randomly (2mu values) except for rho_a[mu]=R_b.
<--Attention: it is set twice in Prover_toom constructor.-->
Randomizer for ElGamal reencryption is generated from group generator using
the exponent a[i].
The ciphertext E[i] (2mu values) is the product of e[i] and rho_a[i].

The algorithm sends commitments c_Dl, c_D0, c_Dm, c_d, c_Delta, and c_d_h.
It also sends a_c_bar and r_ac_bar.
Then it sends vector of ciphertexts E.
<--8 values hard-coded in loop.-->
Finally, it sends commitments c_a and c_B0.
It writes those to file "round_7 ".

## Round 8 (V)

The verifier reads the values from the file and
fills chal_x8 in fill_x8().
Specifically, chal_x[0] is randomly retrieved.
*basis_chal_x8*, the basis of vector e for multi-expo technique of size 2m+2, 
is set to to_basis(ZZ(1), Numbits(ord)) 
at position 0 and to_basis(chal_x8[0], Numbits(ord)) at position 1.
*mul_chal_x8* is the shifted vector e, e(0) = 1, used for multi-expo.
Essentially, mul_chal_x8[0]=1 and mul_chal_x8[1]=chal_x8[0].
For the rest of positions up to the size of chal_x8 (2m+1) chal_x8(i)=chal_x8[0]*chal_x8[i-1]
(modular multiplication), basis_chal_x8[i+1] is the result of to_basis(chal_x8[i],...),
and mul_chal_x8[i=1]=chal_x8[i]


     
## In Round 9 (P) reads *chal_x8* from file.

In Round 9a) (P) calculates vector of ZZ D_h_bar of size n, 
that is, the sum(chal^i*D_h(row(i))) in calculate_D_h_bar(). For first row
D_h[0,j] is set directly to D_h_bar[j] since chal[0] = 1.
So this is a per-column sum of all rows.
Similarly the prover calculates r_Dh_bar = sum(chal^i*r_Dh_bar(i)), 
opening to prove correctness of D_h.
The prover calculates
* *d_bar* vector of size n as chal_x8*D_h(m-1) +d, 
* *r_d_bar* ZZ as chal_x8*r_Dh(m-1)+r_d,  
* *Delta_bar* as chal_x8*d_h+Delta, and
* *r_Delta_bar* as chal_x8*r_dh +r_Delta, 
openings to prove product over elements in D_h->at(m-1)

In Round 9b) (P) calculates A_bar, the sum over the row in A times 
the challenges sum(chal^i*D[i]), and r_A_bar, the sum over the random elements in r_A 
times the challenges (sum[1=i<m](r_D0+(chal_y4*r_A +r_B-r_z)*chal_x8^i) + r_A[m]*chal_x8^m).
These two are the openings to prove permutation in D.




               b)
               c)

## Round 10 (V)